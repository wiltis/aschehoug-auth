import {
  inject,
  readonly,
  ref,
  unref,
  watchEffect
} from "./chunk-G4DFXOZZ.js";

// node_modules/@auth0/auth0-vue/dist/auth0-vue.production.esm.js
var a = Symbol("$auth0");
function s(e, t) {
  var i = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (i[o] = e[o]);
  if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
    var n = 0;
    for (o = Object.getOwnPropertySymbols(e); n < o.length; n++)
      t.indexOf(o[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[n]) && (i[o[n]] = e[o[n]]);
  }
  return i;
}
var r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function c(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function l(e, t) {
  return e(t = { exports: {} }, t.exports), t.exports;
}
var d = l(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: true });
  var i = function() {
    function e2() {
      var e3 = this;
      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t2, i2) {
        var o = e3.locked.get(t2);
        void 0 === o ? void 0 === i2 ? e3.locked.set(t2, []) : e3.locked.set(t2, [i2]) : void 0 !== i2 && (o.unshift(i2), e3.locked.set(t2, o));
      }, this.isLocked = function(t2) {
        return e3.locked.has(t2);
      }, this.lock = function(t2) {
        return new Promise(function(i2, o) {
          e3.isLocked(t2) ? e3.addToLocked(t2, i2) : (e3.addToLocked(t2), i2());
        });
      }, this.unlock = function(t2) {
        var i2 = e3.locked.get(t2);
        if (void 0 !== i2 && 0 !== i2.length) {
          var o = i2.pop();
          e3.locked.set(t2, i2), void 0 !== o && setTimeout(o, 0);
        } else
          e3.locked.delete(t2);
      };
    }
    return e2.getInstance = function() {
      return void 0 === e2.instance && (e2.instance = new e2()), e2.instance;
    }, e2;
  }();
  t.default = function() {
    return i.getInstance();
  };
});
c(d);
var u = c(l(function(e, t) {
  var i = r && r.__awaiter || function(e2, t2, i2, o2) {
    return new (i2 || (i2 = Promise))(function(n2, a3) {
      function s3(e3) {
        try {
          c3(o2.next(e3));
        } catch (e4) {
          a3(e4);
        }
      }
      function r2(e3) {
        try {
          c3(o2.throw(e3));
        } catch (e4) {
          a3(e4);
        }
      }
      function c3(e3) {
        e3.done ? n2(e3.value) : new i2(function(t3) {
          t3(e3.value);
        }).then(s3, r2);
      }
      c3((o2 = o2.apply(e2, t2 || [])).next());
    });
  }, o = r && r.__generator || function(e2, t2) {
    var i2, o2, n2, a3, s3 = { label: 0, sent: function() {
      if (1 & n2[0])
        throw n2[1];
      return n2[1];
    }, trys: [], ops: [] };
    return a3 = { next: r2(0), throw: r2(1), return: r2(2) }, "function" == typeof Symbol && (a3[Symbol.iterator] = function() {
      return this;
    }), a3;
    function r2(a4) {
      return function(r3) {
        return function(a5) {
          if (i2)
            throw new TypeError("Generator is already executing.");
          for (; s3; )
            try {
              if (i2 = 1, o2 && (n2 = 2 & a5[0] ? o2.return : a5[0] ? o2.throw || ((n2 = o2.return) && n2.call(o2), 0) : o2.next) && !(n2 = n2.call(o2, a5[1])).done)
                return n2;
              switch (o2 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {
                case 0:
                case 1:
                  n2 = a5;
                  break;
                case 4:
                  return s3.label++, { value: a5[1], done: false };
                case 5:
                  s3.label++, o2 = a5[1], a5 = [0];
                  continue;
                case 7:
                  a5 = s3.ops.pop(), s3.trys.pop();
                  continue;
                default:
                  if (!((n2 = (n2 = s3.trys).length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {
                    s3 = 0;
                    continue;
                  }
                  if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {
                    s3.label = a5[1];
                    break;
                  }
                  if (6 === a5[0] && s3.label < n2[1]) {
                    s3.label = n2[1], n2 = a5;
                    break;
                  }
                  if (n2 && s3.label < n2[2]) {
                    s3.label = n2[2], s3.ops.push(a5);
                    break;
                  }
                  n2[2] && s3.ops.pop(), s3.trys.pop();
                  continue;
              }
              a5 = t2.call(e2, s3);
            } catch (e3) {
              a5 = [6, e3], o2 = 0;
            } finally {
              i2 = n2 = 0;
            }
          if (5 & a5[0])
            throw a5[1];
          return { value: a5[0] ? a5[1] : void 0, done: true };
        }([a4, r3]);
      };
    }
  };
  Object.defineProperty(t, "__esModule", { value: true });
  var n = "browser-tabs-lock-key";
  function a2(e2) {
    return new Promise(function(t2) {
      return setTimeout(t2, e2);
    });
  }
  function s2(e2) {
    for (var t2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i2 = "", o2 = 0; o2 < e2; o2++)
      i2 += t2[Math.floor(Math.random() * t2.length)];
    return i2;
  }
  var c2 = function() {
    function e2() {
      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.id = Date.now().toString() + s2(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), void 0 === e2.waiters && (e2.waiters = []);
    }
    return e2.prototype.acquireLock = function(t2, r2) {
      return void 0 === r2 && (r2 = 5e3), i(this, void 0, void 0, function() {
        var i2, c3, l2, d2, u2, h2;
        return o(this, function(o2) {
          switch (o2.label) {
            case 0:
              i2 = Date.now() + s2(4), c3 = Date.now() + r2, l2 = n + "-" + t2, d2 = window.localStorage, o2.label = 1;
            case 1:
              return Date.now() < c3 ? [4, a2(30)] : [3, 8];
            case 2:
              return o2.sent(), null !== d2.getItem(l2) ? [3, 5] : (u2 = this.id + "-" + t2 + "-" + i2, [4, a2(Math.floor(25 * Math.random()))]);
            case 3:
              return o2.sent(), d2.setItem(l2, JSON.stringify({ id: this.id, iat: i2, timeoutKey: u2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, a2(30)];
            case 4:
              return o2.sent(), null !== (h2 = d2.getItem(l2)) && (h2 = JSON.parse(h2)).id === this.id && h2.iat === i2 ? (this.acquiredIatSet.add(i2), this.refreshLockWhileAcquired(l2, i2), [2, true]) : [3, 7];
            case 5:
              return e2.lockCorrector(), [4, this.waitForSomethingToChange(c3)];
            case 6:
              o2.sent(), o2.label = 7;
            case 7:
              return i2 = Date.now() + s2(4), [3, 1];
            case 8:
              return [2, false];
          }
        });
      });
    }, e2.prototype.refreshLockWhileAcquired = function(e3, t2) {
      return i(this, void 0, void 0, function() {
        var n2 = this;
        return o(this, function(a3) {
          return setTimeout(function() {
            return i(n2, void 0, void 0, function() {
              var i2, n3;
              return o(this, function(o2) {
                switch (o2.label) {
                  case 0:
                    return [4, d.default().lock(t2)];
                  case 1:
                    return o2.sent(), this.acquiredIatSet.has(t2) ? (i2 = window.localStorage, null === (n3 = i2.getItem(e3)) ? (d.default().unlock(t2), [2]) : ((n3 = JSON.parse(n3)).timeRefreshed = Date.now(), i2.setItem(e3, JSON.stringify(n3)), d.default().unlock(t2), this.refreshLockWhileAcquired(e3, t2), [2])) : (d.default().unlock(t2), [2]);
                }
              });
            });
          }, 1e3), [2];
        });
      });
    }, e2.prototype.waitForSomethingToChange = function(t2) {
      return i(this, void 0, void 0, function() {
        return o(this, function(i2) {
          switch (i2.label) {
            case 0:
              return [4, new Promise(function(i3) {
                var o2 = false, n2 = Date.now(), a3 = false;
                function s3() {
                  if (a3 || (window.removeEventListener("storage", s3), e2.removeFromWaiting(s3), clearTimeout(r2), a3 = true), !o2) {
                    o2 = true;
                    var t3 = 50 - (Date.now() - n2);
                    t3 > 0 ? setTimeout(i3, t3) : i3();
                  }
                }
                window.addEventListener("storage", s3), e2.addToWaiting(s3);
                var r2 = setTimeout(s3, Math.max(0, t2 - Date.now()));
              })];
            case 1:
              return i2.sent(), [2];
          }
        });
      });
    }, e2.addToWaiting = function(t2) {
      this.removeFromWaiting(t2), void 0 !== e2.waiters && e2.waiters.push(t2);
    }, e2.removeFromWaiting = function(t2) {
      void 0 !== e2.waiters && (e2.waiters = e2.waiters.filter(function(e3) {
        return e3 !== t2;
      }));
    }, e2.notifyWaiters = function() {
      void 0 !== e2.waiters && e2.waiters.slice().forEach(function(e3) {
        return e3();
      });
    }, e2.prototype.releaseLock = function(e3) {
      return i(this, void 0, void 0, function() {
        return o(this, function(t2) {
          switch (t2.label) {
            case 0:
              return [4, this.releaseLock__private__(e3)];
            case 1:
              return [2, t2.sent()];
          }
        });
      });
    }, e2.prototype.releaseLock__private__ = function(t2) {
      return i(this, void 0, void 0, function() {
        var i2, a3, s3;
        return o(this, function(o2) {
          switch (o2.label) {
            case 0:
              return i2 = window.localStorage, a3 = n + "-" + t2, null === (s3 = i2.getItem(a3)) ? [2] : (s3 = JSON.parse(s3)).id !== this.id ? [3, 2] : [4, d.default().lock(s3.iat)];
            case 1:
              o2.sent(), this.acquiredIatSet.delete(s3.iat), i2.removeItem(a3), d.default().unlock(s3.iat), e2.notifyWaiters(), o2.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e2.lockCorrector = function() {
      for (var t2 = Date.now() - 5e3, i2 = window.localStorage, o2 = Object.keys(i2), a3 = false, s3 = 0; s3 < o2.length; s3++) {
        var r2 = o2[s3];
        if (r2.includes(n)) {
          var c3 = i2.getItem(r2);
          null !== c3 && (void 0 === (c3 = JSON.parse(c3)).timeRefreshed && c3.timeAcquired < t2 || void 0 !== c3.timeRefreshed && c3.timeRefreshed < t2) && (i2.removeItem(r2), a3 = true);
        }
      }
      a3 && e2.notifyWaiters();
    }, e2.waiters = void 0, e2;
  }();
  t.default = c2;
}));
var h = { timeoutInSeconds: 60 };
var p = { name: "auth0-spa-js", version: "2.0.4" };
var m = () => Date.now();
var g = class extends Error {
  constructor(e, t) {
    super(t), this.error = e, this.error_description = t, Object.setPrototypeOf(this, g.prototype);
  }
  static fromPayload({ error: e, error_description: t }) {
    return new g(e, t);
  }
};
var f = class extends g {
  constructor(e, t, i, o = null) {
    super(e, t), this.state = i, this.appState = o, Object.setPrototypeOf(this, f.prototype);
  }
};
var y = class extends g {
  constructor() {
    super("timeout", "Timeout"), Object.setPrototypeOf(this, y.prototype);
  }
};
var w = class extends y {
  constructor(e) {
    super(), this.popup = e, Object.setPrototypeOf(this, w.prototype);
  }
};
var b = class extends g {
  constructor(e) {
    super("cancelled", "Popup closed"), this.popup = e, Object.setPrototypeOf(this, b.prototype);
  }
};
var k = class extends g {
  constructor(e, t, i) {
    super(e, t), this.mfa_token = i, Object.setPrototypeOf(this, k.prototype);
  }
};
var v = class extends g {
  constructor(e, t) {
    super("missing_refresh_token", `Missing Refresh Token (audience: '${_(e, ["default"])}', scope: '${_(t)}')`), this.audience = e, this.scope = t, Object.setPrototypeOf(this, v.prototype);
  }
};
function _(e, t = []) {
  return e && !t.includes(e) ? e : "";
}
var I = () => window.crypto;
var S = () => {
  const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
  let t = "";
  return Array.from(I().getRandomValues(new Uint8Array(43))).forEach((i) => t += e[i % e.length]), t;
};
var Z = (e) => btoa(e);
var T = (e) => {
  var { clientId: t } = e, i = s(e, ["clientId"]);
  return new URLSearchParams(((e2) => Object.keys(e2).filter((t2) => void 0 !== e2[t2]).reduce((t2, i2) => Object.assign(Object.assign({}, t2), { [i2]: e2[i2] }), {}))(Object.assign({ client_id: t }, i))).toString();
};
var C = (e) => ((e2) => decodeURIComponent(atob(e2).split("").map((e3) => "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2)).join("")))(e.replace(/_/g, "/").replace(/-/g, "+"));
var X = async (e, t) => {
  const i = await fetch(e, t);
  return { ok: i.ok, json: await i.json() };
};
var O = async (e, t, i, o, n, a2, s2 = 1e4) => n ? (async (e2, t2, i2, o2, n2, a3, s3) => {
  return r2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o2, useFormData: s3 }, c2 = a3, new Promise(function(e3, t3) {
    const i3 = new MessageChannel();
    i3.port1.onmessage = function(o3) {
      o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();
    }, c2.postMessage(r2, [i3.port2]);
  });
  var r2, c2;
})(e, t, i, o, s2, n, a2) : (async (e2, t2, i2) => {
  const o2 = new AbortController();
  let n2;
  return t2.signal = o2.signal, Promise.race([X(e2, t2), new Promise((e3, t3) => {
    n2 = setTimeout(() => {
      o2.abort(), t3(new Error("Timeout when executing 'fetch'"));
    }, i2);
  })]).finally(() => {
    clearTimeout(n2);
  });
})(e, o, s2);
async function j(e, t) {
  var { baseUrl: i, timeout: o, audience: n, scope: a2, auth0Client: r2, useFormData: c2 } = e, l2 = s(e, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
  const d2 = c2 ? T(l2) : JSON.stringify(l2);
  return await async function(e2, t2, i2, o2, n2, a3, r3) {
    let c3, l3 = null;
    for (let s2 = 0; s2 < 3; s2++)
      try {
        c3 = await O(e2, i2, o2, n2, a3, r3, t2), l3 = null;
        break;
      } catch (e3) {
        l3 = e3;
      }
    if (l3)
      throw l3;
    const d3 = c3.json, { error: u2, error_description: h2 } = d3, p2 = s(d3, ["error", "error_description"]), { ok: m2 } = c3;
    if (!m2) {
      const t3 = h2 || `HTTP error. Unable to fetch ${e2}`;
      if ("mfa_required" === u2)
        throw new k(u2, t3, p2.mfa_token);
      if ("missing_refresh_token" === u2)
        throw new v(i2, o2);
      throw new g(u2 || "request_error", t3);
    }
    return p2;
  }(`${i}/oauth/token`, o, n || "default", a2, { method: "POST", body: d2, headers: { "Content-Type": c2 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(r2 || p)) } }, t, c2);
}
var x = (...e) => {
  return (t = e.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t))).join(" ");
  var t;
};
var z = class {
  constructor(e, t = "@@auth0spajs@@", i) {
    this.prefix = t, this.suffix = i, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;
  }
  toKey() {
    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
  }
  static fromKey(e) {
    const [t, i, o, n] = e.split("::");
    return new z({ clientId: i, scope: n, audience: o }, t);
  }
  static fromCacheEntry(e) {
    const { scope: t, audience: i, client_id: o } = e;
    return new z({ scope: t, audience: i, clientId: o });
  }
};
var V = class {
  set(e, t) {
    localStorage.setItem(e, JSON.stringify(t));
  }
  get(e) {
    const t = window.localStorage.getItem(e);
    if (t)
      try {
        return JSON.parse(t);
      } catch (e2) {
        return;
      }
  }
  remove(e) {
    localStorage.removeItem(e);
  }
  allKeys() {
    return Object.keys(window.localStorage).filter((e) => e.startsWith("@@auth0spajs@@"));
  }
};
var K = class {
  constructor() {
    this.enclosedCache = function() {
      let e = {};
      return { set(t, i) {
        e[t] = i;
      }, get(t) {
        const i = e[t];
        if (i)
          return i;
      }, remove(t) {
        delete e[t];
      }, allKeys: () => Object.keys(e) };
    }();
  }
};
var W = class {
  constructor(e, t, i) {
    this.cache = e, this.keyManifest = t, this.nowProvider = i || m;
  }
  async setIdToken(e, t, i) {
    var o;
    const n = this.getIdTokenCacheKey(e);
    await this.cache.set(n, { id_token: t, decodedToken: i }), await (null === (o = this.keyManifest) || void 0 === o ? void 0 : o.add(n));
  }
  async getIdToken(e) {
    const t = await this.cache.get(this.getIdTokenCacheKey(e.clientId));
    if (!t && e.scope && e.audience) {
      const t2 = await this.get(e);
      if (!t2)
        return;
      if (!t2.id_token || !t2.decodedToken)
        return;
      return { id_token: t2.id_token, decodedToken: t2.decodedToken };
    }
    if (t)
      return { id_token: t.id_token, decodedToken: t.decodedToken };
  }
  async get(e, t = 0) {
    var i;
    let o = await this.cache.get(e.toKey());
    if (!o) {
      const t2 = await this.getCacheKeys();
      if (!t2)
        return;
      const i2 = this.matchExistingCacheKey(e, t2);
      i2 && (o = await this.cache.get(i2));
    }
    if (!o)
      return;
    const n = await this.nowProvider(), a2 = Math.floor(n / 1e3);
    return o.expiresAt - t < a2 ? o.body.refresh_token ? (o.body = { refresh_token: o.body.refresh_token }, await this.cache.set(e.toKey(), o), o.body) : (await this.cache.remove(e.toKey()), void await (null === (i = this.keyManifest) || void 0 === i ? void 0 : i.remove(e.toKey()))) : o.body;
  }
  async set(e) {
    var t;
    const i = new z({ clientId: e.client_id, scope: e.scope, audience: e.audience }), o = await this.wrapCacheEntry(e);
    await this.cache.set(i.toKey(), o), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.add(i.toKey()));
  }
  async clear(e) {
    var t;
    const i = await this.getCacheKeys();
    i && (await i.filter((t2) => !e || t2.includes(e)).reduce(async (e2, t2) => {
      await e2, await this.cache.remove(t2);
    }, Promise.resolve()), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.clear()));
  }
  async wrapCacheEntry(e) {
    const t = await this.nowProvider();
    return { body: e, expiresAt: Math.floor(t / 1e3) + e.expires_in };
  }
  async getCacheKeys() {
    var e;
    return this.keyManifest ? null === (e = await this.keyManifest.get()) || void 0 === e ? void 0 : e.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;
  }
  getIdTokenCacheKey(e) {
    return new z({ clientId: e }, "@@auth0spajs@@", "@@user@@").toKey();
  }
  matchExistingCacheKey(e, t) {
    return t.filter((t2) => {
      var i;
      const o = z.fromKey(t2), n = new Set(o.scope && o.scope.split(" ")), a2 = (null === (i = e.scope) || void 0 === i ? void 0 : i.split(" ")) || [], s2 = o.scope && a2.reduce((e2, t3) => e2 && n.has(t3), true);
      return "@@auth0spajs@@" === o.prefix && o.clientId === e.clientId && o.audience === e.audience && s2;
    })[0];
  }
};
var P = class {
  constructor(e, t) {
    this.storage = e, this.clientId = t, this.storageKey = `a0.spajs.txs.${this.clientId}`, this.transaction = this.storage.get(this.storageKey);
  }
  create(e) {
    this.transaction = e, this.storage.save(this.storageKey, e, { daysUntilExpire: 1 });
  }
  get() {
    return this.transaction;
  }
  remove() {
    delete this.transaction, this.storage.remove(this.storageKey);
  }
};
var L = (e) => "number" == typeof e;
var R = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"];
var N = l(function(e, t) {
  var i = r && r.__assign || function() {
    return i = Object.assign || function(e2) {
      for (var t2, i2 = 1, o2 = arguments.length; i2 < o2; i2++)
        for (var n2 in t2 = arguments[i2])
          Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
      return e2;
    }, i.apply(this, arguments);
  };
  function o(e2, t2) {
    if (!t2)
      return "";
    var i2 = "; " + e2;
    return true === t2 ? i2 : i2 + "=" + t2;
  }
  function n(e2, t2, i2) {
    return encodeURIComponent(e2).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e3) {
      if ("number" == typeof e3.expires) {
        var t3 = /* @__PURE__ */ new Date();
        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e3.expires), e3.expires = t3;
      }
      return o("Expires", e3.expires ? e3.expires.toUTCString() : "") + o("Domain", e3.domain) + o("Path", e3.path) + o("Secure", e3.secure) + o("SameSite", e3.sameSite);
    }(i2);
  }
  function a2(e2) {
    for (var t2 = {}, i2 = e2 ? e2.split("; ") : [], o2 = /(%[\dA-F]{2})+/gi, n2 = 0; n2 < i2.length; n2++) {
      var a3 = i2[n2].split("="), s3 = a3.slice(1).join("=");
      '"' === s3.charAt(0) && (s3 = s3.slice(1, -1));
      try {
        t2[a3[0].replace(o2, decodeURIComponent)] = s3.replace(o2, decodeURIComponent);
      } catch (e3) {
      }
    }
    return t2;
  }
  function s2() {
    return a2(document.cookie);
  }
  function c2(e2, t2, o2) {
    document.cookie = n(e2, t2, i({ path: "/" }, o2));
  }
  t.__esModule = true, t.encode = n, t.parse = a2, t.getAll = s2, t.get = function(e2) {
    return s2()[e2];
  }, t.set = c2, t.remove = function(e2, t2) {
    c2(e2, "", i(i({}, t2), { expires: -1 }));
  };
});
c(N), N.encode, N.parse, N.getAll;
var U = N.get;
var G = N.set;
var J = N.remove;
var H = { get(e) {
  const t = U(e);
  if (void 0 !== t)
    return JSON.parse(t);
}, save(e, t, i) {
  let o = {};
  "https:" === window.location.protocol && (o = { secure: true, sameSite: "none" }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), G(e, JSON.stringify(t), o);
}, remove(e, t) {
  let i = {};
  (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), J(e, i);
} };
var Y = { get: (e) => H.get(e) || H.get(`_legacy_${e}`), save(e, t, i) {
  let o = {};
  "https:" === window.location.protocol && (o = { secure: true }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), G(`_legacy_${e}`, JSON.stringify(t), o), H.save(e, t, i);
}, remove(e, t) {
  let i = {};
  (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), J(e, i), H.remove(e, t), H.remove(`_legacy_${e}`, t);
} };
var E = { get(e) {
  if ("undefined" == typeof sessionStorage)
    return;
  const t = sessionStorage.getItem(e);
  return null != t ? JSON.parse(t) : void 0;
}, save(e, t) {
  sessionStorage.setItem(e, JSON.stringify(t));
}, remove(e) {
  sessionStorage.removeItem(e);
} };
var F;
var D = ("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX19KX12YXIgaH0pKX0oKTsKCg==", null, false, function(e) {
  return F = F || function(e2, t, i) {
    var o = void 0 === t ? null : t, n = function(e3, t2) {
      var i2 = atob(e3);
      if (t2) {
        for (var o2 = new Uint8Array(i2.length), n2 = 0, a3 = i2.length; n2 < a3; ++n2)
          o2[n2] = i2.charCodeAt(n2);
        return String.fromCharCode.apply(null, new Uint16Array(o2.buffer));
      }
      return i2;
    }(e2, void 0 !== i && i), a2 = n.indexOf("\n", 10) + 1, s2 = n.substring(a2) + (o ? "//# sourceMappingURL=" + o : ""), r2 = new Blob([s2], { type: "application/javascript" });
    return URL.createObjectURL(r2);
  }("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX19KX12YXIgaH0pKX0oKTsKCg==", null, false), new Worker(F, e);
});
var M = {};
var B = class {
  constructor(e, t) {
    this.cache = e, this.clientId = t, this.manifestKey = this.createManifestKeyFrom(this.clientId);
  }
  async add(e) {
    var t;
    const i = new Set((null === (t = await this.cache.get(this.manifestKey)) || void 0 === t ? void 0 : t.keys) || []);
    i.add(e), await this.cache.set(this.manifestKey, { keys: [...i] });
  }
  async remove(e) {
    const t = await this.cache.get(this.manifestKey);
    if (t) {
      const i = new Set(t.keys);
      return i.delete(e), i.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...i] }) : await this.cache.remove(this.manifestKey);
    }
  }
  get() {
    return this.cache.get(this.manifestKey);
  }
  clear() {
    return this.cache.remove(this.manifestKey);
  }
  createManifestKeyFrom(e) {
    return `@@auth0spajs@@::${e}`;
  }
};
var A = { memory: () => new K().enclosedCache, localstorage: () => new V() };
var Q = (e) => A[e];
var q = (e) => {
  const { openUrl: t, onRedirect: i } = e, o = s(e, ["openUrl", "onRedirect"]);
  return Object.assign(Object.assign({}, o), { openUrl: false === t || t ? t : i });
};
var $ = new u();
var ee = class {
  constructor(e) {
    let t, i;
    if (this.userCache = new K().enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = async () => {
      await $.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams) }), "undefined" != typeof window && (() => {
      if (!I())
        throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
      if (void 0 === I().subtle)
        throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    })(), e.cache && e.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e.cache)
      i = e.cache;
    else {
      if (t = e.cacheLocation || "memory", !Q(t))
        throw new Error(`Invalid cache location "${t}"`);
      i = Q(t)();
    }
    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e.legacySameSiteCookie ? H : Y, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((e2) => `auth0.${this.options.clientId}.is.authenticated`)(), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;
    const o = e.useCookiesForTransactions ? this.cookieStorage : E;
    var n;
    this.scope = x("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new P(o, this.options.clientId), this.nowProvider = this.options.nowProvider || m, this.cacheManager = new W(i, i.allKeys ? void 0 : new B(i, this.options.clientId), this.nowProvider), this.domainUrl = (n = this.options.domain, /^https?:\/\//.test(n) ? n : `https://${n}`), this.tokenIssuer = ((e2, t2) => e2 ? e2.startsWith("https://") ? e2 : `https://${e2}/` : `${t2}/`)(this.options.issuer, this.domainUrl), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t && (this.worker = new D());
  }
  _url(e) {
    const t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || p)));
    return `${this.domainUrl}${e}&auth0Client=${t}`;
  }
  _authorizeUrl(e) {
    return this._url(`/authorize?${T(e)}`);
  }
  async _verifyIdToken(e, t, i) {
    const o = await this.nowProvider();
    return ((e2) => {
      if (!e2.id_token)
        throw new Error("ID token is required but missing");
      const t2 = ((e3) => {
        const t3 = e3.split("."), [i3, o3, n3] = t3;
        if (3 !== t3.length || !i3 || !o3 || !n3)
          throw new Error("ID token could not be decoded");
        const a2 = JSON.parse(C(o3)), s2 = { __raw: e3 }, r2 = {};
        return Object.keys(a2).forEach((e4) => {
          s2[e4] = a2[e4], R.includes(e4) || (r2[e4] = a2[e4]);
        }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(C(i3)), claims: s2, user: r2 };
      })(e2.id_token);
      if (!t2.claims.iss)
        throw new Error("Issuer (iss) claim must be a string present in the ID token");
      if (t2.claims.iss !== e2.iss)
        throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e2.iss}", found "${t2.claims.iss}"`);
      if (!t2.user.sub)
        throw new Error("Subject (sub) claim must be a string present in the ID token");
      if ("RS256" !== t2.header.alg)
        throw new Error(`Signature algorithm of "${t2.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);
      if (!t2.claims.aud || "string" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud))
        throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
      if (Array.isArray(t2.claims.aud)) {
        if (!t2.claims.aud.includes(e2.aud))
          throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but was not one of "${t2.claims.aud.join(", ")}"`);
        if (t2.claims.aud.length > 1) {
          if (!t2.claims.azp)
            throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
          if (t2.claims.azp !== e2.aud)
            throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e2.aud}", found "${t2.claims.azp}"`);
        }
      } else if (t2.claims.aud !== e2.aud)
        throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but found "${t2.claims.aud}"`);
      if (e2.nonce) {
        if (!t2.claims.nonce)
          throw new Error("Nonce (nonce) claim must be a string present in the ID token");
        if (t2.claims.nonce !== e2.nonce)
          throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e2.nonce}", found "${t2.claims.nonce}"`);
      }
      if (e2.max_age && !L(t2.claims.auth_time))
        throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
      if (null == t2.claims.exp || !L(t2.claims.exp))
        throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
      if (!L(t2.claims.iat))
        throw new Error("Issued At (iat) claim must be a number present in the ID token");
      const i2 = e2.leeway || 60, o2 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);
      if (n2.setUTCSeconds(t2.claims.exp + i2), o2 > n2)
        throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o2}) is after expiration time (${n2})`);
      if (null != t2.claims.nbf && L(t2.claims.nbf)) {
        const e3 = /* @__PURE__ */ new Date(0);
        if (e3.setUTCSeconds(t2.claims.nbf - i2), o2 < e3)
          throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o2}) is before ${e3}`);
      }
      if (null != t2.claims.auth_time && L(t2.claims.auth_time)) {
        const n3 = /* @__PURE__ */ new Date(0);
        if (n3.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o2 > n3)
          throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o2}) is after last auth at ${n3}`);
      }
      if (e2.organizationId) {
        if (!t2.claims.org_id)
          throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
        if (e2.organizationId !== t2.claims.org_id)
          throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${e2.organizationId}", found "${t2.claims.org_id}"`);
      }
      return t2;
    })({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e, nonce: t, organizationId: i, leeway: this.options.leeway, max_age: (n = this.options.authorizationParams.max_age, "string" != typeof n ? n : parseInt(n, 10) || void 0), now: o });
    var n;
  }
  _processOrgIdHint(e) {
    e ? this.cookieStorage.save(this.orgHintCookieName, e, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
  }
  async _prepareAuthorizeUrl(e, t, i) {
    const o = Z(S()), n = Z(S()), a2 = S(), s2 = ((e2) => {
      const t2 = new Uint8Array(e2);
      return ((e3) => {
        const t3 = { "+": "-", "/": "_", "=": "" };
        return e3.replace(/[+/=]/g, (e4) => t3[e4]);
      })(window.btoa(String.fromCharCode(...Array.from(t2))));
    })(await (async (e2) => {
      const t2 = I().subtle.digest({ name: "SHA-256" }, new TextEncoder().encode(e2));
      return await t2;
    })(a2)), r2 = ((e2, t2, i2, o2, n2, a3, s3, r3) => Object.assign(Object.assign(Object.assign({ client_id: e2.clientId }, e2.authorizationParams), i2), { scope: x(t2, i2.scope), response_type: "code", response_mode: r3 || "query", state: o2, nonce: n2, redirect_uri: s3 || e2.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: "S256" }))(this.options, this.scope, e, o, n, s2, e.redirect_uri || this.options.authorizationParams.redirect_uri || i, null == t ? void 0 : t.response_mode), c2 = this._authorizeUrl(r2);
    return { nonce: n, code_verifier: a2, scope: r2.scope, audience: r2.audience || "default", redirect_uri: r2.redirect_uri, state: o, url: c2 };
  }
  async loginWithPopup(e, t) {
    var i;
    if (e = e || {}, !(t = t || {}).popup && (t.popup = ((e2) => {
      const t2 = window.screenX + (window.innerWidth - 400) / 2, i2 = window.screenY + (window.innerHeight - 600) / 2;
      return window.open("", "auth0:authorize:popup", `left=${t2},top=${i2},width=400,height=600,resizable,scrollbars=yes,status=1`);
    })(), !t.popup))
      throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
    const o = await this._prepareAuthorizeUrl(e.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin);
    t.popup.location.href = o.url;
    const n = await ((e2) => new Promise((t2, i2) => {
      let o2;
      const n2 = setInterval(() => {
        e2.popup && e2.popup.closed && (clearInterval(n2), clearTimeout(a3), window.removeEventListener("message", o2, false), i2(new b(e2.popup)));
      }, 1e3), a3 = setTimeout(() => {
        clearInterval(n2), i2(new w(e2.popup)), window.removeEventListener("message", o2, false);
      }, 1e3 * (e2.timeoutInSeconds || 60));
      o2 = function(s2) {
        if (s2.data && "authorization_response" === s2.data.type) {
          if (clearTimeout(a3), clearInterval(n2), window.removeEventListener("message", o2, false), e2.popup.close(), s2.data.response.error)
            return i2(g.fromPayload(s2.data.response));
          t2(s2.data.response);
        }
      }, window.addEventListener("message", o2);
    }))(Object.assign(Object.assign({}, t), { timeoutInSeconds: t.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));
    if (o.state !== n.state)
      throw new Error("Invalid state");
    const a2 = (null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.organization) || this.options.authorizationParams.organization;
    await this._requestToken({ audience: o.audience, scope: o.scope, code_verifier: o.code_verifier, grant_type: "authorization_code", code: n.code, redirect_uri: o.redirect_uri }, { nonceIn: o.nonce, organizationId: a2 });
  }
  async getUser() {
    var e;
    const t = await this._getIdTokenFromCache();
    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.user;
  }
  async getIdTokenClaims() {
    var e;
    const t = await this._getIdTokenFromCache();
    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.claims;
  }
  async loginWithRedirect(e = {}) {
    var t;
    const i = q(e), { openUrl: o, fragment: n, appState: a2 } = i, r2 = s(i, ["openUrl", "fragment", "appState"]), c2 = (null === (t = r2.authorizationParams) || void 0 === t ? void 0 : t.organization) || this.options.authorizationParams.organization, l2 = await this._prepareAuthorizeUrl(r2.authorizationParams || {}), { url: d2 } = l2, u2 = s(l2, ["url"]);
    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, u2), { appState: a2 }), c2 && { organizationId: c2 }));
    const h2 = n ? `${d2}#${n}` : d2;
    o ? await o(h2) : window.location.assign(h2);
  }
  async handleRedirectCallback(e = window.location.href) {
    const t = e.split("?").slice(1);
    if (0 === t.length)
      throw new Error("There are no query params available for parsing.");
    const { state: i, code: o, error: n, error_description: a2 } = ((e2) => {
      e2.indexOf("#") > -1 && (e2 = e2.substring(0, e2.indexOf("#")));
      const t2 = new URLSearchParams(e2);
      return { state: t2.get("state"), code: t2.get("code") || void 0, error: t2.get("error") || void 0, error_description: t2.get("error_description") || void 0 };
    })(t.join("")), s2 = this.transactionManager.get();
    if (!s2)
      throw new Error("Invalid state");
    if (this.transactionManager.remove(), n)
      throw new f(n, a2 || n, i, s2.appState);
    if (!s2.code_verifier || s2.state && s2.state !== i)
      throw new Error("Invalid state");
    const r2 = s2.organizationId, c2 = s2.nonce, l2 = s2.redirect_uri;
    return await this._requestToken(Object.assign({ audience: s2.audience, scope: s2.scope, code_verifier: s2.code_verifier, grant_type: "authorization_code", code: o }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: c2, organizationId: r2 }), { appState: s2.appState };
  }
  async checkSession(e) {
    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
      if (!this.cookieStorage.get("auth0.is.authenticated"))
        return;
      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated");
    }
    try {
      await this.getTokenSilently(e);
    } catch (e2) {
    }
  }
  async getTokenSilently(e = {}) {
    var t;
    const i = Object.assign(Object.assign({ cacheMode: "on" }, e), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), { scope: x(this.scope, null === (t = e.authorizationParams) || void 0 === t ? void 0 : t.scope) }) }), o = await ((e2, t2) => {
      let i2 = M[t2];
      return i2 || (i2 = e2().finally(() => {
        delete M[t2], i2 = null;
      }), M[t2] = i2), i2;
    })(() => this._getTokenSilently(i), `${this.options.clientId}::${i.authorizationParams.audience}::${i.authorizationParams.scope}`);
    return e.detailedResponse ? o : null == o ? void 0 : o.access_token;
  }
  async _getTokenSilently(e) {
    const { cacheMode: t } = e, i = s(e, ["cacheMode"]);
    if ("off" !== t) {
      const e2 = await this._getEntryFromCache({ scope: i.authorizationParams.scope, audience: i.authorizationParams.audience || "default", clientId: this.options.clientId });
      if (e2)
        return e2;
    }
    if ("cache-only" !== t) {
      if (!await (async (e2, t2 = 3) => {
        for (let i2 = 0; i2 < t2; i2++)
          if (await e2())
            return true;
        return false;
      })(() => $.acquireLock("auth0.lock.getTokenSilently", 5e3), 10))
        throw new y();
      try {
        if (window.addEventListener("pagehide", this._releaseLockOnPageHide), "off" !== t) {
          const e3 = await this._getEntryFromCache({ scope: i.authorizationParams.scope, audience: i.authorizationParams.audience || "default", clientId: this.options.clientId });
          if (e3)
            return e3;
        }
        const e2 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(i) : await this._getTokenFromIFrame(i), { id_token: o, access_token: n, oauthTokenScope: a2, expires_in: s2 } = e2;
        return Object.assign(Object.assign({ id_token: o, access_token: n }, a2 ? { scope: a2 } : null), { expires_in: s2 });
      } finally {
        await $.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
      }
    }
  }
  async getTokenWithPopup(e = {}, t = {}) {
    var i;
    const o = Object.assign(Object.assign({}, e), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), { scope: x(this.scope, null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.scope) }) });
    return t = Object.assign(Object.assign({}, h), t), await this.loginWithPopup(o, t), (await this.cacheManager.get(new z({ scope: o.authorizationParams.scope, audience: o.authorizationParams.audience || "default", clientId: this.options.clientId }))).access_token;
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  _buildLogoutUrl(e) {
    null !== e.clientId ? e.clientId = e.clientId || this.options.clientId : delete e.clientId;
    const t = e.logoutParams || {}, { federated: i } = t, o = s(t, ["federated"]), n = i ? "&federated" : "";
    return this._url(`/v2/logout?${T(Object.assign({ clientId: e.clientId }, o))}`) + n;
  }
  async logout(e = {}) {
    const t = q(e), { openUrl: i } = t, o = s(t, ["openUrl"]);
    null === e.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(e.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove("@@user@@");
    const n = this._buildLogoutUrl(o);
    i ? await i(n) : false !== i && window.location.assign(n);
  }
  async _getTokenFromIFrame(e) {
    const t = Object.assign(Object.assign({}, e.authorizationParams), { prompt: "none" }), i = this.cookieStorage.get(this.orgHintCookieName);
    i && !t.organization && (t.organization = i);
    const { url: o, state: n, nonce: a2, code_verifier: s2, redirect_uri: r2, scope: c2, audience: l2 } = await this._prepareAuthorizeUrl(t, { response_mode: "web_message" }, window.location.origin);
    try {
      if (window.crossOriginIsolated)
        throw new g("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
      const t2 = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, i2 = await ((e2, t3, i3 = 60) => new Promise((o2, n2) => {
        const a3 = window.document.createElement("iframe");
        a3.setAttribute("width", "0"), a3.setAttribute("height", "0"), a3.style.display = "none";
        const s3 = () => {
          window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener("message", r3, false));
        };
        let r3;
        const c3 = setTimeout(() => {
          n2(new y()), s3();
        }, 1e3 * i3);
        r3 = function(e3) {
          if (e3.origin != t3)
            return;
          if (!e3.data || "authorization_response" !== e3.data.type)
            return;
          const i4 = e3.source;
          i4 && i4.close(), e3.data.response.error ? n2(g.fromPayload(e3.data.response)) : o2(e3.data.response), clearTimeout(c3), window.removeEventListener("message", r3, false), setTimeout(s3, 2e3);
        }, window.addEventListener("message", r3, false), window.document.body.appendChild(a3), a3.setAttribute("src", e2);
      }))(o, this.domainUrl, t2);
      if (n !== i2.state)
        throw new Error("Invalid state");
      const d2 = await this._requestToken(Object.assign(Object.assign({}, e.authorizationParams), { code_verifier: s2, code: i2.code, grant_type: "authorization_code", redirect_uri: r2, timeout: e.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2 });
      return Object.assign(Object.assign({}, d2), { scope: c2, oauthTokenScope: d2.scope, audience: l2 });
    } catch (e2) {
      throw "login_required" === e2.error && this.logout({ openUrl: false }), e2;
    }
  }
  async _getTokenUsingRefreshToken(e) {
    const t = await this.cacheManager.get(new z({ scope: e.authorizationParams.scope, audience: e.authorizationParams.audience || "default", clientId: this.options.clientId }));
    if (!(t && t.refresh_token || this.worker)) {
      if (this.options.useRefreshTokensFallback)
        return await this._getTokenFromIFrame(e);
      throw new v(e.authorizationParams.audience || "default", e.authorizationParams.scope);
    }
    const i = e.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o = "number" == typeof e.timeoutInSeconds ? 1e3 * e.timeoutInSeconds : null;
    try {
      const n = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), { grant_type: "refresh_token", refresh_token: t && t.refresh_token, redirect_uri: i }), o && { timeout: o }));
      return Object.assign(Object.assign({}, n), { scope: e.authorizationParams.scope, oauthTokenScope: n.scope, audience: e.authorizationParams.audience || "default" });
    } catch (t2) {
      if ((t2.message.indexOf("Missing Refresh Token") > -1 || t2.message && t2.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback)
        return await this._getTokenFromIFrame(e);
      throw t2;
    }
  }
  async _saveEntryInCache(e) {
    const { id_token: t, decodedToken: i } = e, o = s(e, ["id_token", "decodedToken"]);
    this.userCache.set("@@user@@", { id_token: t, decodedToken: i }), await this.cacheManager.setIdToken(this.options.clientId, e.id_token, e.decodedToken), await this.cacheManager.set(o);
  }
  async _getIdTokenFromCache() {
    const e = this.options.authorizationParams.audience || "default", t = await this.cacheManager.getIdToken(new z({ clientId: this.options.clientId, audience: e, scope: this.scope })), i = this.userCache.get("@@user@@");
    return t && t.id_token === (null == i ? void 0 : i.id_token) ? i : (this.userCache.set("@@user@@", t), t);
  }
  async _getEntryFromCache({ scope: e, audience: t, clientId: i }) {
    const o = await this.cacheManager.get(new z({ scope: e, audience: t, clientId: i }), 60);
    if (o && o.access_token) {
      const { access_token: e2, oauthTokenScope: t2, expires_in: i2 } = o, n = await this._getIdTokenFromCache();
      return n && Object.assign(Object.assign({ id_token: n.id_token, access_token: e2 }, t2 ? { scope: t2 } : null), { expires_in: i2 });
    }
  }
  async _requestToken(e, t) {
    const { nonceIn: i, organizationId: o } = t || {}, n = await j(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e), this.worker), a2 = await this._verifyIdToken(n.id_token, i, o);
    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n), { decodedToken: a2, scope: e.scope, audience: e.audience || "default" }), n.scope ? { oauthTokenScope: n.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgIdHint(a2.claims.org_id), Object.assign(Object.assign({}, n), { decodedToken: a2 });
  }
};
var te = class {
};
function ie(t) {
  return new Promise((i) => {
    !function(t2, i2) {
      const o = watchEffect(() => {
        t2() && (i2(), o());
      });
    }(t, i);
  });
}
function oe(e) {
  (null == e ? void 0 : e.redirect_uri) && (console.warn("Using `redirect_uri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version"), e.authorizationParams = e.authorizationParams || {}, e.authorizationParams.redirect_uri = e.redirect_uri, delete e.redirect_uri);
}
var ne = ref(null);
var ae = class {
  constructor(e, o) {
    var n, a2;
    this.clientOptions = e, this.pluginOptions = o, this._isLoading = ref(true), this._isAuthenticated = ref(false), this._user = ref({}), this._idTokenClaims = ref(), this._error = ref(null), this.isLoading = readonly(this._isLoading), this.isAuthenticated = readonly(this._isAuthenticated), this.user = readonly(this._user), this.idTokenClaims = readonly(this._idTokenClaims), this.error = readonly(this._error), n = this, a2 = ["constructor"], Object.getOwnPropertyNames(Object.getPrototypeOf(n)).filter((e2) => !a2.includes(e2)).forEach((e2) => n[e2] = n[e2].bind(n));
  }
  install(e) {
    this._client = new ee(Object.assign(Object.assign({}, this.clientOptions), { auth0Client: { name: "auth0-vue", version: "2.2.0" } })), this.__checkSession(e.config.globalProperties.$router), e.config.globalProperties.$auth0 = this, e.provide(a, this), ne.value = this;
  }
  async loginWithRedirect(e) {
    return oe(e), this._client.loginWithRedirect(e);
  }
  async loginWithPopup(e, t) {
    return oe(e), this.__proxy(() => this._client.loginWithPopup(e, t));
  }
  async logout(e) {
    return (null == e ? void 0 : e.openUrl) || false === (null == e ? void 0 : e.openUrl) ? this.__proxy(() => this._client.logout(e)) : this._client.logout(e);
  }
  async getAccessTokenSilently(e = {}) {
    return oe(e), this.__proxy(() => this._client.getTokenSilently(e));
  }
  async getAccessTokenWithPopup(e, t) {
    return oe(e), this.__proxy(() => this._client.getTokenWithPopup(e, t));
  }
  async checkSession(e) {
    return this.__proxy(() => this._client.checkSession(e));
  }
  async handleRedirectCallback(e) {
    return this.__proxy(() => this._client.handleRedirectCallback(e));
  }
  async __checkSession(e) {
    var t, i, o;
    const n = window.location.search;
    try {
      if ((n.includes("code=") || n.includes("error=")) && n.includes("state=") && !(null === (t = this.pluginOptions) || void 0 === t ? void 0 : t.skipRedirectCallback)) {
        const t2 = await this.handleRedirectCallback(), o2 = null == t2 ? void 0 : t2.appState, n2 = null !== (i = null == o2 ? void 0 : o2.target) && void 0 !== i ? i : "/";
        return window.history.replaceState({}, "", "/"), e && e.push(n2), t2;
      }
      await this.checkSession();
    } catch (t2) {
      window.history.replaceState({}, "", "/"), e && e.push((null === (o = this.pluginOptions) || void 0 === o ? void 0 : o.errorPath) || "/");
    }
  }
  async __refreshState() {
    this._isAuthenticated.value = await this._client.isAuthenticated(), this._user.value = await this._client.getUser(), this._idTokenClaims.value = await this._client.getIdTokenClaims(), this._isLoading.value = false;
  }
  async __proxy(e, t = true) {
    let i;
    try {
      i = await e(), this._error.value = null;
    } catch (e2) {
      throw this._error.value = e2, e2;
    } finally {
      t && await this.__refreshState();
    }
    return i;
  }
};
async function se(e, t, i) {
  const n = async () => !!unref(e.isAuthenticated) || (await e.loginWithRedirect(Object.assign({ appState: { target: t.fullPath } }, i)), false);
  return unref(e.isLoading) ? (await ie(() => !unref(e.isLoading)), n()) : n();
}
function re(e) {
  const { app: t, redirectLoginOptions: i } = !e || "config" in e ? { app: e, redirectLoginOptions: void 0 } : e;
  return async (e2) => se(t ? t.config.globalProperties.$auth0 : unref(ne), e2, i);
}
async function ce(e) {
  return se(unref(ne), e);
}
function le(e, t) {
  return oe(e), new ae(e, t);
}
function de() {
  return inject(a);
}
export {
  a as AUTH0_INJECTION_KEY,
  ae as Auth0Plugin,
  K as InMemoryCache,
  V as LocalStorageCache,
  te as User,
  ce as authGuard,
  le as createAuth0,
  re as createAuthGuard,
  de as useAuth0
};
//# sourceMappingURL=@auth0_auth0-vue.js.map
